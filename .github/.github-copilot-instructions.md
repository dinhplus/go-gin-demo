# GitHub Copilot Instructions

## Project Overview
This is a Go web application built with the Gin framework following a clean architecture pattern. The project includes both REST API endpoints and GraphQL API with JWT authentication, Swagger documentation, GORM for database operations, and a role-based permission system.

## Code Structure & Patterns

### Architecture
- **Clean Architecture**: Follow the established pattern with clear separation between handlers, services, repositories, and models
- **Layers**:
  - `cmd/`: Application entry point
  - `internal/handler/`: HTTP handlers, GraphQL handlers, and routing
  - `internal/service/`: Business logic layer
  - `internal/repository/`: Data access layer
  - `internal/model/`: Domain models and structs
  - `internal/graphql/`: GraphQL schema, resolvers, and generated code
  - `docs/`: Swagger documentation

### GraphQL Integration
- **GraphQL Schema**: Located in `internal/graphql/schema/`
- **Generated Code**: Auto-generated GraphQL types and resolvers in `internal/graphql/generated/`
- **Resolvers**: Custom resolver implementations in `internal/graphql/resolvers/`
- **Configuration**: `gqlgen.yml` for GraphQL code generation settings

### Naming Conventions
- Use **snake_case** for JSON tags and database column names
- Use **PascalCase** for Go structs, interfaces, and exported functions
- Use **camelCase** for unexported functions and variables
- File names should use **snake_case** (e.g., `user_handler.go`)
- Package names should be short and lowercase

### Database & Models
- Use GORM for all database operations
- All models should include proper GORM tags and JSON tags
- Use foreign key relationships with proper GORM associations
- Example model structure:
```go
type User struct {
    ID           int        `json:"id" gorm:"primaryKey"`
    Name         string     `json:"name"`
    Email        string     `json:"email"`
    DepartmentID int        `json:"department_id"`
    Department   Department `json:"department" gorm:"foreignKey:DepartmentID"`
}
```

### API Handlers
- All handlers should include Swagger annotations
- Follow the established pattern: handlers call services, services call repositories
- Use proper HTTP status codes and error handling
- Include JWT authentication where required
- Example handler structure:
```go
// CreateUser godoc
// @Summary      Create a new user
// @Description  Create a new user with the provided information
// @Tags         users
// @Accept       json
// @Produce      json
// @Param        user  body      model.User  true  "User data"
// @Success      201   {object}  model.User
// @Failure      400   {object}  map[string]string
// @Security     BearerAuth
// @Router       /users [post]
func CreateUser(c *gin.Context) {
    // Implementation
}
```

### Services
- Keep business logic in the service layer
- Services should handle validation and business rules
- Call repositories for data operations
- Return appropriate errors that handlers can translate to HTTP responses

### Repositories
- Handle all database operations
- Use GORM methods and best practices
- Include proper error handling for database operations
- Support pagination, filtering, and sorting where applicable

## Dependencies & Imports
- Use `github.com/gin-gonic/gin` for HTTP framework
- Use `gorm.io/gorm` for ORM operations
- Use `github.com/swaggo/gin-swagger` for API documentation
- Use `github.com/appleboy/gin-jwt/v2` for JWT authentication
- Import internal packages using the module name: `my-gin-app/internal/...`

## Security & Authentication
- Implement JWT-based authentication using the existing middleware
- Use role-based access control (RBAC) with the permission middleware
- Validate user permissions before allowing access to protected endpoints
- Hash passwords before storing in database

## Error Handling
- Use consistent error response format
- Return appropriate HTTP status codes
- Include meaningful error messages for API consumers
- Log errors appropriately for debugging

## Testing
- Write unit tests for services and repositories
- Use table-driven tests where appropriate
- Mock dependencies using interfaces
- Follow Go testing conventions

## Swagger Documentation
- All API endpoints must include complete Swagger annotations
- Include proper tags for grouping endpoints
- Document all request/response models
- Include security requirements for protected endpoints
- Use meaningful summaries and descriptions

## Code Quality Guidelines
- Follow Go best practices and idioms
- Use meaningful variable and function names
- Keep functions focused and single-purpose
- Include comments for exported functions and complex logic
- Handle errors explicitly and appropriately
- Use context for request-scoped operations

## File Organization
- Group related functionality in the same package
- Keep files focused on a single responsibility
- Use consistent file naming across the project
- Separate concerns between different layers

## Example Code Generation Preferences
When generating new code, please:
1. Follow the existing project structure and patterns
2. Include complete Swagger documentation for REST endpoints
3. Include complete GraphQL schema definitions for GraphQL operations
4. Implement proper error handling
5. Use the established naming conventions
6. Include appropriate GORM and JSON tags
7. Follow the handler -> service -> repository pattern
8. Include JWT authentication for protected endpoints
9. Use the existing import patterns and dependencies

## GraphQL Best Practices

### Schema Design
- Keep GraphQL schema files in `internal/graphql/schema/`
- Use descriptive field names and types
- Include proper input types for mutations
- Use nullable fields (`*string`) for optional fields
- Follow GraphQL naming conventions (camelCase for fields)

### Resolvers
- Implement resolvers in `internal/graphql/resolvers/`
- Connect resolvers to existing services (don't duplicate business logic)
- Handle authentication in resolvers when needed
- Use context for request-scoped data
- Return appropriate GraphQL errors

### Code Generation
- Run `go run github.com/99designs/gqlgen generate` after schema changes
- Don't manually edit generated files in `internal/graphql/generated/`
- Update `gqlgen.yml` for configuration changes
- Use autobind for existing models when possible

### Authentication & Security
- Use JWT authentication middleware for protected GraphQL endpoints
- Extract user claims from context in resolvers
- Implement field-level authorization when needed
- Validate input data in resolvers

### Error Handling
- Return GraphQL-appropriate errors
- Include meaningful error messages
- Handle database errors gracefully
- Use structured error responses

## Common Operations
- When creating CRUD operations, generate complete handler, service, and repository methods
- Include pagination support for list operations (both REST and GraphQL)
- Implement proper validation for input data
- Use transactions for operations that modify multiple tables
- Include soft delete functionality where appropriate using GORM's DeletedAt
- For GraphQL: Define schema first, then implement resolvers
- For REST: Include Swagger documentation
- Always consider both REST and GraphQL when adding new features

## GraphQL Development Workflow
1. Define/update GraphQL schema in `internal/graphql/schema/`
2. Run `go run github.com/99designs/gqlgen generate` to generate code
3. Implement resolver logic in `internal/graphql/resolvers/`
4. Connect resolvers to existing services
5. Test using GraphQL Playground at `/playground`
6. Add authentication middleware for protected operations
